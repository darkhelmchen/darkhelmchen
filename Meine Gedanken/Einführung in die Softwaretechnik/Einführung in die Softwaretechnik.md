# Einführung in die Softwaretechnik - [[Manfred Broy]] 
---
## Teil I Grundlagen und Begriffsbildung

### 1 Grundlagen
#### 1.1 Software is Eating the World
	1.1.1 Herausforderungen in der Softwareentwicklung
	1.1.2 Zielsetzung des Software Engineering
	1.1.3 Prinzipien und Erfolgsfaktoren
#### 1.2 Grundlegende Begriffe
#### 1.3 Kernthemen der Softwaretechnik
	1.3.1 Erfassung und Verfeinerung der Anforderungen
	1.3.2 Architektur
	1.3.3 Implementierung, Integration und Verifikation
	1.3.4 Betrieb und Evolution
	1.3.5 Vorgehensweisen in der Softwareentwicklung
### 2 Eigenschaften und Strukturen von Softwaresystemen
#### 2.1 Charakterisierung von Softwaresystemen
				2.1.1 Der Kontext
				2.1.2 Systemverhalten, Schnittstellen und Funktionen
				2.1.3 Sichten auf Softwaresysteme
#### 2.2 Qualitätseigenschaften von Softwaresystemen
				2.2.1 Produkt- und Nutzungsqualität
				2.2.2 Qualität in der Nutzung
				2.2.3 Qualität in der Entwicklung und Evolution
				2.2.4 Qualität im Betrieb
				2.2.5 Qualität in der Vermarktung (Vermarktbarkeit)
#### 2.3 Messung von Systemeigenschaften
				2.3.1 Messung und Vermessung von Software
				2.3.2 Festlegung von Metriken
				2.3.3 Softwaremetriken

### 3 Vorgehensmodelle in der Softwareentwicklung
#### 3.1 Was ist ein Vorgehensmodell?
#### 3.2 Grundlegende Vorgehensmodelle und Prozessbeschreibungen
			3.2.1 Phasenorientierte Modelle und sequenzielles Vorgehen
			3.2.2 Iteratives und inkrementelles Vorgehen
			3.2.3 Prototyping
			3.2.4 Agile Vorgehensweisen
#### 3.3 Das V-Modell XT
			3.3.1 Rollen im V-Modell XT
			3.3.2 V-Modell XT Produkte für die Systementwicklung
			3.3.3 Vorgehensweisen im V-Modell XT
#### 3.4 Scrum
			3.4.1 Rollen in Scrum
			3.4.2 Scrum Artefakte und Prozess
			3.4.3 Anforderungen an die Organisation
			3.4.4 Scrum in der Praxis
			3.4.5 Skalierung von Scrum
			3.4.6 Scrumban
#### 3.5 Rollen und Verantwortlichkeiten
			3.5.1 Der Product Owner
			3.5.2 Weitere zentrale Projektrollen

### 4 Modelle in der Softwareentwicklung und ihre Beschreibung
#### 4.1 Warum Modellierung?
#### 4.2 Modelle und ihre Beschreibung
			4.2.1 Grundsätzliches zur Modellbildung in der Informatik
			4.2.2 Mathematische Modellierung von Informationsverarbeitung
			4.2.3 Grafische Modellierung am Beispiel UML
#### 4.3 Modellierung von Daten
			4.3.1 Algebraische Spezifikation
			4.3.2 Entity-Relationship-Modelle
			4.3.3 UML-Klassendiagramme
			4.3.4 Typ- und Sortendeklarationen
#### 4.4 Spezifikation von Funktionen und Prozeduren
			4.4.1 Spezifikation von Funktionen
			4.4.2 Spezifikation von Prozeduren
			4.4.3 Operationen in UML-Klassendiagrammen
#### 4.5 Modellierung von Zuständen
			4.5.1 Zustandsmaschinen mit Ein- und Ausgabe
			4.5.2 Zustandsmaschinen in der UML
#### 4.6 Modellierung von verteilten Systemen
			4.6.1 Komponenten und Schnittstellen
			4.6.2 Architekturen
			4.6.3 Daten- und Kontrollfluss
			4.6.4 Prozesse


## Teil II Anforderungsanalyse

### 5 Anforderungsanalyse und Anforderungsmanagement
#### 5.1 Ziele und Aufgaben einer Software
#### 5.2 Die zentrale Rolle der Anforderungen
			5.2.1 Die Nutzer und ihr Erlebnis stehen im Zentrum
			5.2.2 Grundstruktur der Anforderungen
			5.2.3 Anforderungsanalyse
			5.2.4 Klassifikation von Anforderungen
			5.2.5 Anforderungen an die Systemverlässlichkeit
#### 5.3 Kernaufgaben in der Erarbeitung der Systemanforderungen
			5.3.1 Kernartefakte in der Anforderungsanalyse
			5.3.2 Grundlegendes Vorgehen in der Anforderungserhebung
#### 5.4 Rollen in der Anforderungsanalyse
#### 5.5 Management von Anforderungen im Produktlebenszyklus
			5.5.1 Änderungsmanagement
			5.5.2 Versions- und Konfigurationsmanagement
			5.5.3 Anforderungsverifizierbarkeit
			5.5.4 Anforderungsverfolgung
			5.5.5 Anforderungsbegründung

### 6 Produkt- und Qualitätsanforderungen
  #### 6.1 Produktanforderungen
			6.1.1 Funktionsarchitektur und Anwendungsfälle
			6.1.2 Mensch-Maschine Interaktion
  #### 6.2 Qualitätsanforderungen
			6.2.1 Funktionsbezogene Qualitätsanforderungen
			6.2.2 Nutzungsbezogene Qualitätsanforderungen
			6.2.3 Entwicklungsbezogene Qualitätsanforderungen
			6.2.4 Qualitätsattribute

### 7 Vorgehen in der Anforderungserhebung
  #### 7.1 Grundsätzliches Vorgehen in der Anforderungserhebung
			7.1.1 Domänenanalyse
			7.1.2 Allgemeiner Prozess der Anforderungserhebung
			7.1.3 Das Lastenheft und Anwenderforderungen
			7.1.4 Anforderungsfestlegung und Dokumentation
  #### 7.2 Techniken für die Anforderungserhebung
			7.2.1 Anforderungsquellen
			7.2.2 Kreativitätstechniken
  #### 7.3 Methoden für die anforderungsgetriebene Entwicklung
			7.3.1 Design Thinking
			7.3.2 Feature-driven Development
  #### 7.4 Anforderungserhebung im Agilen Vorgehen
			7.4.1 User Stories
			7.4.2 Agile Praktiken in der Anforderungserhebung
			7.4.3 Definition of Ready und Definition of Done
  #### 7.5 Modellierung von Anforderungen
			7.5.1 Modellierung von Anwendungsfällen
			7.5.2 Detaillierte Modellierung von Anforderungen
  #### 7.6 Qualitätssicherung für Anforderungen
			7.6.1 Allgemeine Qualitätsaspekte von Anforderungen
			7.6.2 Validierung von Anforderungen
			7.6.3 Verifizierbarkeit von Anforderungen


## Teil III Systementwurf und Architekturspezifikation

### 8 Grundlagen und Prinzipien des Architekturentwurfs
#### 8.1 Strukturierung von Systemen
			8.1.1 Softwarekomponenten
			8.1.2 Erarbeitung der System- und Softwarearchitektur
			8.1.3 Funktionen und Funktionsarchitektur
			8.1.4 Architekturmodelle für Softwaresysteme
			8.1.5 Perspektiven des Architekturentwurfs
			8.1.6 Die zentrale Rolle des Architekten
#### 8.2 Prinzipien des Architekturentwurfs
			8.2.1 Das Gebot der Einfachheit: KISS
			8.2.2 Kopplung und Kohäsion
			8.2.3 Kapselung und Information Hiding
			8.2.4 Separation of Concerns
			8.2.5 Teile und Herrsche
			8.2.6 Design by Contract
#### 8.3 Wiederverwendung im Architekturentwurf
			8.3.1 Was ist Wiederverwendung?
			8.3.2 Herausforderungen in der Wiederverwendung
			8.3.3 Strategien der Wiederverwendung


### 9 Architekturentwurf und Architekturmodellierung
#### 9.1 Grundsätzliches Vorgehen im Architekturentwurf
			9.1.1 Allgemeiner Prozess des Architekturentwurfs
			9.1.2 Entwurfsstrategien im Architekturentwurf
			9.1.3 Modellierung von Daten
			9.1.4 Modellierung von Nutzungsschnittstellen
			9.1.5 Berücksichtigung von Datensicherheit und Datenschutz
			9.1.6 Fehlerbehandlung
#### 9.2 Der Grobentwurf: Entwicklung der Systemarchitektur
			9.2.1 Prinzipien im Architektur- und Komponentenentwurf
			9.2.2 Black-Box Spezifikation und Schnittstellen
			9.2.3 Wiederverwendung von Komponenten und Modulen
#### 9.3 Der Feinentwurf: Entwicklung der Softwarearchitektur
			9.3.1 Softwarearchitektur zur Entwurfs- und Laufzeit
			9.3.2 Abstraktion und Verfeinerung
#### 9.4 Dokumentation der Architektur: Architekturspezifikation
			9.4.1 Das Pflichtenheft und die Systemanforderungen
			9.4.2 Nachhaltige Dokumentation der Softwarearchitektur
			9.4.3 Dokumentation von Entwurfsentscheidungen
#### 9.5 Qualitätssicherung des Architekturentwurfs
			9.5.1 Evaluation von Systementwürfen
			9.5.2 Architekturreviews

### 10 Nutzung bewährten Architekturwissens
#### 10.1 Wiederverwendung im Architekturentwurf
#### 10.2 Klassenbibliotheken und Idiome und Entwurfsmuster
			10.2.1 Frameworks
			10.2.2 Generische Klassenbibliotheken für die Softwareentwicklung
			10.2.3 Domänenspezifische Frameworks und Klassenbibliotheken
			10.2.4 Referenzarchitekturen
#### 10.3 Entwurfsmuster
			10.3.1 Allgemeine Beschreibung von Entwurfsmustern
			10.3.2 Klassifizierung von Entwurfsmustern
			10.3.3 Anwendung von Entwurfsmustern
#### 10.4 Architekturmuster
			10.4.1 Klassifizierung von Architekturmustern
			10.4.2 Anwendungsbereiche von Architekturmustern
#### 10.5 Entwurfsregel S.O.L.I.D.
			10.5.1 Single Responsibility Principle
			10.5.2 Open-Closed Principle
			10.5.3 Liskov's Substitution Principle
			10.5.4 Interface Segregation Principle
			10.5.5 Dependency Inversion Principle




## Teil IV Implementierung, Integration und Qualitätssicherung von Software

### [[11 Implementierung von Softwaresystemen]]
#### [[11.1 Implementierung von Software]]
			11.1.1 Codearchitektur und Codequalität
			11.1.2 Entscheidungen vor Beginn der Implementierung
#### [[11.2 Grundsätzliche Aufgaben in der Implementierung]]
			11.2.1 Implementierung des Datenmodells
			11.2.2 Implementierung der Programmlogik und der Module
			11.2.3 Realisierung der Nutzerschnittstelle
#### 11.3 Codierung
			11.3.1 Codierungsrichtlinien
			11.3.2 Dokumentation von Quellcode
			11.3.3 Clean Code
			11.3.4 Pair Programming
#### 11.4 Modellbasierte Entwicklung und Codegenerierung
			11.4.1 Grundidee der modellbasierten Entwicklung
			11.4.2 Beispiel der Modellbasierten Entwicklung
#### 11.5 Source Code Management
			11.5.1 Versionskontrollsysteme
			11.5.2 Organisation und Umgang mit Versionskontrollsystemen
			11.5.3 Techniken und Werkzeuge

### 12 Verifikation und Integration von Software
#### 12.1 Qualitätssicherung der Implementierung
			12.1.1 Begriffe und Konzepte
			12.1.2 Codeinspektionen und Codereviews
			12.1.3 Funktionale Korrektheit
			12.1.4 Verifikation durch Korrektheitsbeweis und Model Checking
#### 12.2 Grundsätzliches Vorgehen im Testen von Software
			12.2.1 Prinzipien
			12.2.2 Allgemeiner Testprozess
			12.2.3 Methodik des Testens
			12.2.4 Entwurfsregel F.I.R.S.T.
			12.2.5 Unit Testing
			12.2.6 Test-Driven Development
#### 12.3 Strategien für Software- und Systemintegration
			12.3.1 Grundsätzliche Test- und Integrationsstufen
			12.3.2 Vorgehen bei der Integration
#### 12.4 Kontinuierliche Integration und Auslieferung
			12.4.1 Vorgehen in der Kontinuierlichen Softwareentwicklung
			12.4.2 DevOps

### 13 Softwareevolution
#### 13.1 Transition in die Einsatzumgebung
			13.1.1 Auslieferung und Abnahme
			13.1.2 Installation und Inbetriebnahme
			13.1.3 Übergang in die Wartung
#### 13.2 Wartung, Pflege und Weiterentwicklung von Software
			13.2.1 Was ist Softwarewartung?
			13.2.2 Aufgaben in der Wartung von Software
			13.2.3 Methoden, Techniken und Werkzeuge in der Wartung von Software
			